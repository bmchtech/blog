<!doctype html><html lang=en><head><title>explaining GBA Real-Time Clock (RTC) :: beanmachine tech.</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="intro there&rsquo;s not much documentation online about how the GBA RTC works, so this blog post will attempt to demystify that. to be honest, i still don&rsquo;t fully know how the RTC works. i&rsquo;ll try to explain what i do know, but DISCLAIMER: what i say may not be 100% accurate. you should be able to successfully emulate a working RTC though using this blogpost.
"><meta name=keywords content="development linux blog research emulation architecture systems"><meta name=robots content="noodp"><link rel=canonical href=https://beanmachine.alt.icu/post/rtc/><link rel=stylesheet href=https://beanmachine.alt.icu/assets/style.css><link rel=stylesheet href=https://beanmachine.alt.icu/assets/beanmachine.css><link rel=apple-touch-icon href=https://beanmachine.alt.icu/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://beanmachine.alt.icu/favicon.ico><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="explaining GBA Real-Time Clock (RTC)"><meta property="og:description" content="intro there&rsquo;s not much documentation online about how the GBA RTC works, so this blog post will attempt to demystify that. to be honest, i still don&rsquo;t fully know how the RTC works. i&rsquo;ll try to explain what i do know, but DISCLAIMER: what i say may not be 100% accurate. you should be able to successfully emulate a working RTC though using this blogpost.
"><meta property="og:url" content="https://beanmachine.alt.icu/post/rtc/"><meta property="og:site_name" content="beanmachine tech."><meta property="og:image" content="https://beanmachine.alt.icu/favicon.ico"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-02-04 00:00:00 +0000 UTC"></head><body class=beanmachine><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>beanmachine</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>about</a></li><li><a href=/contact>contact</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>about</a></li><li><a href=/contact>contact</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://beanmachine.alt.icu/post/rtc/>explaining GBA Real-Time Clock (RTC)</a></h1><div class=post-meta><span class=post-date>2022-02-04
</span><span class=post-author>:: zayd</span></div><span class=post-tags>#<a href=https://beanmachine.alt.icu/tags/dev/>dev</a>&nbsp;
#<a href=https://beanmachine.alt.icu/tags/gba/>gba</a>&nbsp;</span><div class=table-of-contents><h2>contents</h2><nav id=TableOfContents><ul><li><a href=#intro>intro</a></li><li><a href=#gba-gpio>gba gpio</a></li><li><a href=#gba-rtc>gba rtc</a></li><li><a href=#sources-couldnt-have-done-this-without-these>sources (couldn&rsquo;t have done this without these)</a></li></ul></nav></div><div class=post-content><div><h2 id=intro>intro<a href=#intro class=hanchor arialabel=Anchor>&#8983;</a></h2><p>there&rsquo;s not much documentation online about how the GBA RTC works, so this blog post will attempt to demystify that. to be honest, i still don&rsquo;t fully know how the RTC works. i&rsquo;ll try to explain what i <em>do</em> know, but DISCLAIMER: what i say may not be 100% accurate. you should be able to successfully emulate a working RTC though using this blogpost.</p><h2 id=gba-gpio>gba gpio<a href=#gba-gpio class=hanchor arialabel=Anchor>&#8983;</a></h2><p>if you already know how gba gpio works, then you can safely <a href=/post/rtc/#gba-rtc>skip this section</a>.</p><p>basically, some gba cartridges contain extra circuits that the ROM communicates with using this interface called <strong>GPIO</strong>. examples of these extra circuits are the solar sensor, the gyro sensor, the gba rumble, and of course, the gba RTC. there&rsquo;s three mmio registers that the ROM can use to communicate with a GPIO device:</p><p><code>0800'00C4 : IO Port Data</code><br><code>0800'00C6 : IO Port Direction</code><br><code>0800'00C8 : IO Port Control</code></p><p>the <strong>Data</strong> register is used to send and receive data from the GPIO device. the ROM can write to this register to send data over to the device, and read from the register to, well, receive data. this register is 4 bits wide.</p><p>the <strong>Direction</strong> register is used to specify the direction for the <strong>Data</strong> register. the <strong>Direction</strong> register is also 4 bits wide. each bit 0-3 in the <strong>Direction</strong> register corresponds to a bit in the <strong>Data</strong> register. a value of 0 means the associated data bit is &ldquo;in&rdquo;, while a value of 1 means the associated data bit is &ldquo;out&rdquo;. what does this mean? well, you can only read bit &ldquo;x&rdquo; in the <strong>Data</strong> register if that bit is specified as &ldquo;in&rdquo; in the <strong>Direction</strong> register. likewise, you can only write to bit &ldquo;x&rdquo; in the <strong>Data</strong> register if that data bit is &ldquo;our&rdquo;. you can think of the <strong>Direction</strong> register as a sort of mask on the <strong>Data</strong> register. note that you, as the emulator developer, don&rsquo;t have to do any sort of writing to the <strong>Direction</strong> register. the ROM will write to it as it likes, and you should reflect the behavior of the <strong>Data</strong> register accordingly.</p><p>the <strong>Control</strong> register is a lot easier. it&rsquo;s 1 bit wide (bit 0), and if it has a value of 0, then the <strong>all</strong> GPIO registers become write-only (reads return 0). if it has a value of 1, you can read from the registers as normal.</p><p>these registers will act as an interface to the GPIO device to allow the ROM to send and receive data to and from the device.</p><h2 id=gba-rtc>gba rtc<a href=#gba-rtc class=hanchor arialabel=Anchor>&#8983;</a></h2><p>the rtc is probably one of the most bizarre things to wrap your head around at first. let&rsquo;s first start out with a higher level explanation of how a ROM can communicate with the RTC. essentially, the ROM can send two types of commands - read commands, and write commands. read commands allow the ROM to read the full value of some of the registers on the RTC. likewise, write commands allow the ROM to write to some of the registers on the RTC. here&rsquo;s a list of the RTC registers, along with their read/write behaviors.</p><table><thead><tr><th>name</th><th>length (in bytes) <img width=450/></th><th>read behavior <img width=1500/></th><th>write behavior</th><th>notes</th></tr></thead><tbody><tr><td>Control</td><td>1</td><td><strong>bit 1</strong>: unknown, but it can be written to and read from, so you should preserve its value<br><strong>bit 3</strong>: per minute IRQ (1 = fire a Gamepak IRQ every 30 seconds)<br><strong>bit 6</strong>: 12/24 hour mode<br><strong>bit 7</strong>: power off (cleared on read, 1 = failure / time lost)</td><td>same as read behavior, but bit 7 is read-only.</td><td>any unused bits are zero.</td></tr><tr><td>Date/Time</td><td>7</td><td><strong>byte 0</strong>: current year in BCD, 00h ~ 99h = 2000 ~ 2099<br><strong>byte 1</strong>: current month in BCD, 01h ~ 12h = January ~ December (bits 5-7 unused)<br><strong>byte 2</strong>: current day in BCD, 01h ~ 31h (bits 6-7 unused)<br><strong>byte 3</strong>: day of week in BCD, 0h ~ 6h = Sunday ~ Saturday. (bits 3-7 unused)<br><strong>bytes 4 - 6</strong>: see the Time register below.</td><td>according to GBATEK, these can all be written to. but both mGBA and NBA disallow writes. you can probably ignore writes to Date/Time, unless you&rsquo;re implementing some sort of time machine.</td><td>see above</td></tr><tr><td>Time</td><td>3</td><td><strong>byte 0</strong>: current hour in BCD. 00h ~ 23h in 24 hour mode, 00h ~ 11h in 12 hour mode. bits 6-7 are unused.<br><strong>byte 1</strong>: current minute in BCD, 00h ~ 59h. bit 7 is unused.<br><strong>byte 2</strong>: current second in BCD, 00h ~ 59h. bit 7 is unused.</td><td>see above.</td><td>see above.</td></tr><tr><td>Reset</td><td>0</td><td>n/a</td><td>GBATEK says all registers are zeroed, except the month register which gets set to 01h. however, mGBA and NBA both only zero the control register, and that&rsquo;s what makes the most sense to me anyway.</td><td></td></tr><tr><td>IRQ</td><td>0</td><td>n/a</td><td>forces a gamepak interrupt.</td><td></td></tr></tbody></table><p>okay, now that you (hopefully) understand what the different registers are in the RTC and what happens if you read/write to them, i&rsquo;m going to explain how the ROM reads/writes to these registers in the first place. so, the GPIO data register on the GBA has 4 bits. 3 of those bits are used for GBA RTC. here&rsquo;s the general mapping:</p><table><thead><tr><th style=text-align:left>bit</th><th style=text-align:left>name</th><th style=text-align:left>description</th></tr></thead><tbody><tr><td style=text-align:left>0</td><td style=text-align:left>SCK</td><td style=text-align:left>source clock</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>SIO</td><td style=text-align:left>serial IO</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left>CS</td><td style=text-align:left>chip select</td></tr><tr><td style=text-align:left>3</td><td style=text-align:left></td><td style=text-align:left>unused</td></tr></tbody></table><p>the first key thing to understand is that the <strong>SIO</strong> bit is the only bit that encodes actual command data. the command data is sent bit-by-bit through the <strong>SIO</strong> bit to the chip. the <strong>SCK</strong> and <strong>CS</strong> bits are used in conjunction to tell the RTC chip when to sample the <strong>SIO</strong> bit. the ROM will use all three bits to send commands to the RTC chip.</p><p>here&rsquo;s how a typical transfer works, from the perspective of the ROM:</p><ol><li>while <strong>SCK</strong> is high, <strong>CS</strong> rises. this indicates to the RTC chip the start of a new command. <strong>CS</strong> will now stay high until the command is completed.</li><li><strong>SCK</strong> will now toggle between low and high. every time <strong>SCK</strong> rises, the RTC chip will sample the <strong>SIO</strong> bit. 8 such samples will occur to fill a byte.</li><li>if the command was a write command, then you should write n bytes to the RTC as described in step 2, where n is the size of the register. if the command was a read command, do the same, except instead of writing to SIO, you read from SIO.</li><li><strong>CS</strong> goes low. this indicates that the command has completed.</li></ol><p>you can sorta think of <strong>CS</strong> as a &ldquo;command in progress&rdquo; signal, and <strong>SCK</strong> as a &ldquo;sample SIO&rdquo; signal.</p><p>you may have noticed i neglected to mention whether or not the data in <strong>SIO</strong> is sent in LSB order of MSB order. this is where things get really stupid - it can be either. the <strong>command</strong> byte must have bits <code>0110</code> in bit positions 4-7. if it does not, then simply reverse the <strong>command</strong> byte (why does everything in emulation have to be so needlessly complicated and unnecessary oh my g-)</p><p>anyway, there are 4 bits remaining. if bit 0 is 0, this command is a write command. if its 1, this command is a read command. bits 1-3 specify the register that the command operates on:</p><table><thead><tr><th>bits 1-3</th><th>register</th></tr></thead><tbody><tr><td>0</td><td>Reset</td></tr><tr><td>1</td><td>Control</td></tr><tr><td>2</td><td>Date/Time</td></tr><tr><td>3</td><td>Time</td></tr><tr><td>6</td><td>IRQ</td></tr></tbody></table><p>so, to summarize, here&rsquo;s an example: say the ROM wrote something like <code>46h</code> to <strong>SIO</strong> using the process described above. in this case, we need to reverse the commands bits because <code>6h</code> is in the lower nibble, so we reverse <code>46h</code> to get <code>62h</code>. bit <code>0</code> of <code>62h</code> is <code>0</code>, which means this is a write command. bits <code>1-3</code> of <code>62h</code> is <code>1h</code>, which means the ROM is trying to write to the <strong>Control</strong> register. the size of the control register is 1 byte, so we should expect 1 more byte of data to be sent through SIO before the ROM ends the command.</p><p>alright, that should about wrap it up! if you have any questions at all, feel free to create a github issue or contact me! :)</p><h2 id=sources-couldnt-have-done-this-without-these>sources (couldn&rsquo;t have done this without these)<a href=#sources-couldnt-have-done-this-without-these class=hanchor arialabel=Anchor>&#8983;</a></h2><p>fleroviux - <a href=https://github.com/nba-emu/NanoBoyAdvance>NanoBoyAdvance</a></p><p>endrift - <a href=https://github.com/mgba-emu/mgba>mGBA</a></p><p>Martin Korth - <a href=https://problemkaputt.de/gbatek.htm>GBATEK</a></p><p>pret team - <a href=https://github.com/pret/pokeemerald>Pokemon Emerald Decompilation Project</a></p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://beanmachine.alt.icu/post/d_on_gba/><span class=button__icon>←</span>
<span class=button__text>porting D to GBA</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2019-2024. CC BY-NC-SA 4.0</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://beanmachine.alt.icu/assets/main.js></script><script src=https://beanmachine.alt.icu/assets/prism.js></script></div></body></html>