<!doctype html><html lang=en><head><title>Investigating Multiplication on the Gameboy Advance :: beanmachine tech.</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The Gameboy Advance has a pretty neat CPU - the ARM7TDMI. And by neat, I mean a chaotic and sadistic bundle of questionable design decisions. Seriously, they decided that the program counter should be a general purpose register. Why??? Insert simile here. I&rsquo;m not even joking, you can use the program counter as the output to, say, an XOR instruction. Or an AND instruction.
"><meta name=keywords content="development linux blog research emulation architecture systems"><meta name=robots content="noodp"><link rel=canonical href=https://beanmachine.alt.icu/post/multiply/><link rel=stylesheet href=https://beanmachine.alt.icu/assets/style.css><link rel=stylesheet href=https://beanmachine.alt.icu/assets/beanmachine.css><link rel=apple-touch-icon href=https://beanmachine.alt.icu/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://beanmachine.alt.icu/favicon.ico><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Investigating Multiplication on the Gameboy Advance"><meta property="og:description" content="The Gameboy Advance has a pretty neat CPU - the ARM7TDMI. And by neat, I mean a chaotic and sadistic bundle of questionable design decisions. Seriously, they decided that the program counter should be a general purpose register. Why??? Insert simile here. I&rsquo;m not even joking, you can use the program counter as the output to, say, an XOR instruction. Or an AND instruction.
"><meta property="og:url" content="https://beanmachine.alt.icu/post/multiply/"><meta property="og:site_name" content="beanmachine tech."><meta property="og:image" content="https://beanmachine.alt.icu/favicon.ico"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2024-10-19 00:00:00 +0000 UTC"><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"]]}}</script></head><body class=beanmachine><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>beanmachine</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>about</a></li><li><a href=/contact>contact</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>about</a></li><li><a href=/contact>contact</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://beanmachine.alt.icu/post/multiply/>Investigating Multiplication on the Gameboy Advance</a></h1><div class=post-meta><span class=post-date>2024-10-19
</span><span class=post-author>:: zayd</span></div><span class=post-tags>#<a href=https://beanmachine.alt.icu/tags/dev/>dev</a>&nbsp;
#<a href=https://beanmachine.alt.icu/tags/gba/>gba</a>&nbsp;
#<a href=https://beanmachine.alt.icu/tags/arm/>arm</a>&nbsp;</span><div class=post-content><div><p>The Gameboy Advance has a pretty neat CPU - the ARM7TDMI. And by neat, I mean a chaotic and
sadistic bundle of questionable design decisions. Seriously, they decided that the program counter should
be a <em>general purpose register</em>. Why??? Insert simile here. I&rsquo;m not even joking, you can use the program
counter as the output to, say, an XOR instruction. Or an AND instruction.</p><p>Or a multiply instruction.</p><p>The ARM7TDMI&rsquo;s multiplication instruction has a pretty interesting side effect. Here the manual says that
after a multiplication instruction executes, the carry and overflow flags are <code>UNPREDICTABLE</code>.</p><p><img alt="An image of the ARM7TDMI manual explaining that the carry and overflow flags are <code>UNPREDICTABLE</code> after a multiply instruction." src=/manual.png></p><p>As if anything else in this god forsaken CPU was predictable. What this means is that software cannot and
should not rely on the value of the carry flag after multiplication executes. It can be set to anything. Any
value. 0, 1, a horse, whatever. This has been a source of memes in the emudev community for a bit -
people would frequently joke about how the implementation of the carry flag may as well be <code>cpu.flags.c = rand() & 1;</code>. And they had a point - the carry flag seemed to defy all patterns; nobody understood why it
behaves the way it does. But the one thing we did know, was that the carry flag seemed to be
<em>deterministic</em>. That is, under the same set of inputs to a multiply instruction, the flag would be set to the
same value. This was big news, because it meant that understanding the carry flag could give us key
insight into how this CPU performs multiplication.</p><p>And just to get this out of the way, the carry flag&rsquo;s behavior after multiplication isn&rsquo;t an important detail to
emulate at all. Software doesn&rsquo;t rely on it. And if software <em>did</em> rely on it, then screw that software, those
developers got what was coming to them. But the carry flag is a meme, and it&rsquo;s a really tough puzzle, and
that was motivation enough for me to give it a go. Little did I know it&rsquo;d take <em>3 years</em> of on and off work.</p><h1 id=standard-algorithm>Standard Algorithm<a href=#standard-algorithm class=hanchor arialabel=Anchor>&#8983;</a></h1><p>What&rsquo;s the simplest, most basic multiplication algorithm you can think of to multiply a <span style=color:#3a7dc9><strong>multiplier</strong></span> with a <span style=color:#dc6a76><strong>multiplicand</strong></span>? One really easy way is to
leverage the distributive property of multiplication like so:</p>$$
\color{#3a7dc9}123\color{#4A4358} \cdot \color{#DC6A76}4 \color{#4A4358}=
\color{#3a7dc9}{100 \color{#4A4358} \cdot \color{#DC6A76}4} \color{#4A4358} + \color{#3a7dc9}{20 \color{#4A4358} \cdot \color{#DC6A76}4} \color{#4A4358} + \color{#3a7dc9}{3 \color{#4A4358} \cdot \color{#DC6A76}4}
$$<p>There&rsquo;s two steps here - first compute the addends, then sum them. This
is the basic two-step process you&rsquo;ll find in lots of multiplication algorithms - most of them simply differ in
how they compute the addends, or how they add the addends together. We can generalize this algorithm
to binary pretty easily too:</p>$$
\color{#3a7dc9}1101 \color{#4A4358} \cdot \color{#DC6A76}11\color{#4A4358} =
\color{#3a7dc9}{1000 \color{#4A4358} \cdot\color{#DC6A76} 11} \color{#4A4358} + \color{#3a7dc9}{100 \color{#4A4358} \cdot \color{#DC6A76} 11} \color{#4A4358} + \color{#3a7dc9}{0 \color{#4A4358} \cdot\color{#DC6A76} 11} \color{#4A4358} + \color{#3a7dc9}{1 \color{#4A4358} \cdot \color{#DC6A76}11}
$$<p>The convenient thing about binary is that it&rsquo;s all ones and zeros, meaning the addends are only ever <code>0</code>, or
the <span style=color:#dc6a76><strong>multiplicand</strong></span> left shifted by some factor. This makes the addends easy to compute, and means that for
an <code>N-bit</code> number, we need to produce <code>N</code> different addends, and add them all up to get the result.
That&rsquo;s slow. We can do better.</p><h1 id=modified-booths-algorithm>Modified Booth&rsquo;s Algorithm<a href=#modified-booths-algorithm class=hanchor arialabel=Anchor>&#8983;</a></h1><p>The main slowness of the Standard Algorithm is that it requires you to add a <em>lot</em> of numbers together.
Modified Booth&rsquo;s algorithm is an improvement on the Standard Algorithm that cuts the number of addends in two. Let&rsquo;s start with the standard definition for multiplication, written as a summation. Note that <code>m[i]</code> is defined as the bit at index <code>i</code> of <code>m</code> when <code>0 &lt;= i &lt; n</code>.</p>$$
\begin{aligned}
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=0}^{n-1} (2^i \cdot \color{#3a7dc9}{m[i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) \cr
\end{aligned}
$$<p>Now we apply the following transformations. Yes I know this looks scary, you could skip to the final equation if you want.</p>$$
\begin{align}
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=0}^{n-1} (2^i \cdot \color{#3a7dc9}{m[i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr\cr
&\quad\text{Separate the summation into even and odd elements:}\cr \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=0}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) \cr
\cr&     \quad\text{                  Split the second summation into two more summations:}\cr \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=0}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (2 - 1) \cdot \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=0}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + 2 \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) - \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=0}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 2} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) - \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) \cr \cr&     \quad\text{                  Pull out a single element from each summation, one at a time:}\cr \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 2} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) - \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358})\cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + \sum_{i=0}^{\frac{n}{2}-2} (2^{2i + 2} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) - \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{n} \cdot \color{#3a7dc9}{m[n - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + \sum_{i=0}^{\frac{n}{2}-2} (2^{2i + 2} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) - \sum_{i=1}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{n} \cdot \color{#3a7dc9}{m[n - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2 \cdot \color{#3a7dc9}{m[1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr
\cr&     \quad\text{                  Manipulate the range of the second summation to match the ranges of the other two:}\cr \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) - \sum_{i=1}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{n} \cdot \color{#3a7dc9}{m[n - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2 \cdot \color{#3a7dc9}{m[1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr
\cr&     \quad\text{                  So that we can combine the summations now:}\cr \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{2i} \cdot \color{#3a7dc9}{m[2i - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} - 2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{n} \cdot \color{#3a7dc9}{m[n - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2 \cdot \color{#3a7dc9}{m[1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr
\cr&     \quad\text{                  Some tidywork...}\cr \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{2i} \cdot \color{#3a7dc9}{m[2i - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} - 2 \cdot 2^{2i} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{n} \cdot \color{#3a7dc9}{m[n - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2 \cdot \color{#3a7dc9}{m[1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=1}^{\frac{n}{2}-1} ((2^{2i} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cdot(\color{#3a7dc9}{m[2i]}\color{#4A4358} + \color{#3a7dc9}{m[2i - 1]}\color{#4A4358} - 2 \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} )) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{n} \cdot \color{#3a7dc9}{m[n - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2 \cdot \color{#3a7dc9}{m[1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr
\end{align}
$$<p>Whew. Did you get all of that? Why did we do all this? Well, note this part of the summation:</p>$$
\begin{aligned}
(\color{#3a7dc9}{m[2i]}\color{#4A4358} + \color{#3a7dc9}{m[2i - 1]}\color{#4A4358} - 2 \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358})
\end{aligned}
$$<p>This is always one of <code>(-2, -1, 0, 1, 2)</code>.</p><p>Multiplication by those five numbers is easy to calculate in hardware (well, negation is tricky - the algorithm implements negation as bitwise inversion, with an additional 1 added at a later stage. More information about this is given later).</p><p>Note also that if we define:</p>$$
\color{#3a7dc9}{m[-1]}\color{#4A4358} = 0
$$<p>and</p>$$
\begin{aligned}
\text{For}&\text{ unsigned multiplication:}\cr\cr
&x \geq n, \color{#3a7dc9}{m[x]}\color{#4A4358} = 0\cr\cr
\text{For}&\text{ signed multiplication:}\cr\cr
&x \geq n, \color{#3a7dc9}{m[x]}\color{#4A4358} = \color{#3a7dc9}m[n-1]\cr\cr
\end{aligned}
$$<p>Then the leftover three terms outside the summation can be absorbed into the summation, by expanding the summations range by one on both boundaries. And so we have:</p>$$
\begin{aligned}
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &= \sum_{i=0}^{\frac{n}{2}} ((2^{2i} \cdot \color{#DC6A76} \alpha \color{#4A4358}) \cdot (\color{#3a7dc9}{m[2i]}\color{#4A4358} + \color{#3a7dc9}{m[2i - 1]}\color{#4A4358} - 2 \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358}))\cr
\end{aligned}
$$<p>Before all this mathematical chaos, we used to have <code>n</code> addends. Now we have just over half that many addends. We can model the generation of an addend sans the left shift using the following C code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// represents a 3-bit chunk that is used to determine an addend&#39;s value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> u8 BoothChunk;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> BoothRecodingOutput {
</span></span><span style=display:flex><span>    u64  recoded_output;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> carry;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// booth_chunk is a 3-bit number representing bits [2i - 1 .. 2i + 1]
</span></span></span><span style=display:flex><span><span style=color:#75715e>// of the multiplier
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> BoothRecodingOutput <span style=color:#a6e22e>booth_recode</span>(u64 input, BoothChunk booth_chunk) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (booth_chunk) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> BoothRecodingOutput) {            <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> BoothRecodingOutput) {        input, <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> BoothRecodingOutput) {        input, <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> BoothRecodingOutput) {    <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> input, <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>4</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> BoothRecodingOutput) { <span style=color:#f92672>~</span>(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> input), <span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>5</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> BoothRecodingOutput) {       <span style=color:#f92672>~</span>input, <span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>6</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> BoothRecodingOutput) {       <span style=color:#f92672>~</span>input, <span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> BoothRecodingOutput) {            <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=how-to-add-stuff--efficiently->How to Add Stuff ✨ Efficiently ✨<a href=#how-to-add-stuff--efficiently- class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Now that we have the addends, it&rsquo;s time to actually add them up to produce the result. However, using a
conventional full adder, the ARM7TDMI is only fast enough to add two numbers per cycle. Which means,
you gotta spend 16 cycles to add all 17 addends, which is uselessly slow. The reason full adders are so
slow is because of the carry propagation - bit <code>N</code> of the result can&rsquo;t be determined till bit <code>N - 1</code> is
determined. Can we eliminate this issue?</p><p>Introducing&mldr; <em>drum roll</em>&mldr; carry save adders (CSAs)! These are genius - instead of outputting a single <code>N-bit</code> result, CSAs output one <code>N-bit</code> result without carry propagation, and one <code>N-bit</code> list of carries computed from each bit. At first this seems kind of silly - are CSAs really adding two <code>N-bit</code> operands and
producing two <code>N-bit</code> results? What&rsquo;s the point? The point is that you can actually fit in an extra operand,
and turn three <code>N-bit</code> operands into two <code>N-bit</code> results. Like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> CSAOutput {
</span></span><span style=display:flex><span>    u64 output;
</span></span><span style=display:flex><span>    u64 carry;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> CSAOutput <span style=color:#a6e22e>perform_csa</span>(u64 a, u64 b, u64 c) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Bit i in result should be set if there is either 1 set bit in 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// src1/src2/src3 at index i, or 3 set bits in src1/src2/src3 at
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// index i. Similarly, bit i in carries should be set if there&#39;s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 2 or 3 set bits in src1/src2/src3 at index i. See if you can
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// convince yourself why this is correct.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    u64 output <span style=color:#f92672>=</span> a <span style=color:#f92672>^</span> b <span style=color:#f92672>^</span> c;
</span></span><span style=display:flex><span>    u64 carry  <span style=color:#f92672>=</span> (a <span style=color:#f92672>&amp;</span> b) <span style=color:#f92672>|</span> (b <span style=color:#f92672>&amp;</span> c) <span style=color:#f92672>|</span> (c <span style=color:#f92672>&amp;</span> a);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> CSAOutput) { output, carry };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So you can chain a bunch of CSAs to get yourself down to two addends, and then you can shove the two
<code>N-bit</code> results into a regular adder, like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>u64 <span style=color:#a6e22e>add_csa_results</span>(u64 result, u64 carries) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Exercise for the reader: Why do you suppose we multiply
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// carries by 2? Think about how a full adder is implemented,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// and what the variable &#34;carries&#34; in the csa function actually
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// represents. The answer is given after this code block.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result <span style=color:#f92672>+</span> carries <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The reason we multiply <code>carries</code> by two is because, if we think about how a full adder works, the carry out
from bit <code>i</code> is added to bits <code>i + 1</code> of the addends. So, bit <code>i</code> of carries has double the &ldquo;weight&rdquo; of bit <code>i</code> of
result. This is a <strong>very</strong> important detail that will come in handy later, so do make sure you understand
this.</p><h1 id=parallelism>Parallelism<a href=#parallelism class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Until now, we&rsquo;ve mostly treated &ldquo;generate the addends&rdquo; and &ldquo;add the addends&rdquo; as two separate, entirely
discrete steps of the algorithm. But, turns out, we can do both of these steps <em>at the same time</em>. We
know we can only add 4 addends per cycle, so what if we generate 4 addends per cycle, and compress
them using four CSAs to generate only two addends? So, we pipe 4 CSAs into each other, allowing us to process 6 <code>N</code>-bit inputs into two <code>N + 8</code> bit outputs. Each CSA widens the
output by <code>2</code>, because the carries that the CSA outputs has twice the weight of the sum, meaning the
carries needs to be represented using an <code>N + 1</code> bit number. Each cycle, we can generate 4 addends,
feed them into 4 of the 6 outputs of this CSA array, and then when we have our two results, feed those
results back to the very top of the CSA array for the next cycle. We can initialize those two inputs to the
CSA array with <code>0</code>s. Or, if we want to be clever, we can implement multiply accumulate by initializing one
of those two inputs with the accumulate value, and get multiply accumulate for free. This trick is what the
ARM7TDMI employs to do multiply accumulate. (This is a moot point, because the CPU is stupid and can only read two register values at a time per cycle. So, using an accumulate causes the CPU to take
an extra cycle <em>anyway</em>).</p><h1 id=early-termination>Early Termination<a href=#early-termination class=hanchor arialabel=Anchor>&#8983;</a></h1><p>The ARM7TDMI does something really clever here. In our current model of the algorithm, there are 4
cycles of CSA compression, where each cycle <code>i</code> processes bits <code>8 * i</code> to <code>8 * i + 7</code> of the <span style=color:#3a7dc9><strong>multiplier</strong></span>.
(explain this in previous section). The observation is that if the remaining upper bits of the <span style=color:#3a7dc9><strong>multiplier</strong></span> are all
zeros, then, we can skip that cycle, since the addends produced will be all zeros, which cannot possibly
affect the values of the partial result + partial carry. We can do the same trick if the remaining upper bits
are all ones (assuming we are performing a signed multiplication), as those also produce addends that
are all zeros.</p><h1 id=putting-it-all-together>Putting it all together<a href=#putting-it-all-together class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Here&rsquo;s a rough diagram, provided by Steve Furber in his book, Arm System-On-Chip Architecture:</p><p><img alt="An image of the high level overview of the multiplier&rsquo;s organization, provided by Steve Furber in his book, Arm System-On-Chip Architecture" src=/booth.png></p><p>Partial Sum / Partial Carry contain the results obtained by the CSAs, and are rotated right by 8 on each cycle. Rm is recoded using booth&rsquo;s algorithm to produce the addends for the CSA array.</p><p>Ok, but remember when I said (make sure I said this) that there will be an elegant way to handle booth&rsquo;s negation of the addends? The way the algorithm gets around this is kind of genius. Remember how the carry output of a CSA has to be left shifted by 1? Well, this left-shift creates a zero in the LSB of the carry output of the CSA, so why don&rsquo;t we just put the carry in that bit? Like so:
<a name=perform_csa_array></a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> CSAOutput <span style=color:#a6e22e>perform_csa_array</span>(u64 partial_sum, u64 partial_carry, 
</span></span><span style=display:flex><span>                                   BoothRecodingOutput addends) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> CSAOutput csa_output <span style=color:#f92672>=</span> { partial_sum, partial_carry };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> CSAOutput final_csa_output <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        csa_output.output <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0x1FFFFFFFFULL</span>;
</span></span><span style=display:flex><span>        csa_output.carry  <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0x1FFFFFFFFULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> CSAOutput result <span style=color:#f92672>=</span> <span style=color:#a6e22e>perform_csa</span>(csa_output.output, addends.m[i].recoded_output <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x1FFFFFFFFULL</span>, csa_output.carry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Inject the carry caused by booth recoding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        result.carry <span style=color:#f92672>&lt;&lt;=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        result.carry <span style=color:#f92672>|=</span> addends.m[i].carry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Take the bottom two bits and inject them into the final output.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// The value of the bottom two bits will not be changed by future
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// addends, because those addends must be at least 4 times as big
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// as the current addend. By directly injecting these two bits, the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// hardware saves some space on the chip.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        final_csa_output.output <span style=color:#f92672>|=</span> (result.output <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i);
</span></span><span style=display:flex><span>        final_csa_output.carry  <span style=color:#f92672>|=</span> (result.carry  <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The next CSA will only operate on the upper bits - as explained
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// in the previous comment.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        result.output <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        result.carry  <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        csa_output <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    final_csa_output.output <span style=color:#f92672>|=</span> csa_output.output <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>    final_csa_output.carry  <span style=color:#f92672>|=</span> csa_output.carry  <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> final_csa_output;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>(Yes, this insanity is indeed done by the actual CPU.)</p><h1 id=fatal-contradiction>Fatal Contradiction<a href=#fatal-contradiction class=hanchor arialabel=Anchor>&#8983;</a></h1><p>So I lied to you all. There&rsquo;s a small, but very meaningful difference between the algorithm I described and
the ARM7TDMI&rsquo;s algorithm. Let&rsquo;s consider the following multiplication:</p>$$
\color{#3a7dc9}0x000000FF\color{#4A4358} \cdot \color{#DC6A76}0x00000001 \color{#4A4358}
$$<p>How many cycles should this take? 1, right? Because the upper 24 bits of the <span style=color:#3a7dc9><strong>multiplier</strong></span> are zeros, then the
second, third, and fourth cycles of addends will all be zeros&mldr; right?
Right?
Well, that&rsquo;s how long it takes the ARM7TDMI to do it. So what&rsquo;s the issue? Turns out, the second cycle of
the algorithm does have a single non-zero addend:</p>$$
\begin{aligned}
&\text{Chunk #1: }\color{#3a7dc9}\text{0b001}\cr
&\text{Chunk #2: }\color{#3a7dc9}\text{0b000}\cr
&\text{Chunk #3: }\color{#3a7dc9}\text{0b000}\cr
&\text{Chunk #4: }\color{#3a7dc9}\text{0b000}\cr
\end{aligned}
$$<p>Because the LSB of Chunk #1 uses the MSB of Chunk #3 of Cycle #1, our algorithm would be forced to
take 2 cycles of CSAs. And yet, on the ARM7TDMI, this multiplication would terminate early, after only 1 cycle of CSAs. And there doesn&rsquo;t seem to be a good way around this. And so I sat there thinking of
workarounds.</p><p><strong>Proposed solution #1:</strong> What if the ARM7TDMI actually processes 5 chunks per cycle?</p><p><strong>Rebuttal:</strong> If that were the case, then the algorithm would be able to process 9 bits on the first cycle,
which it cannot do.</p><p><strong>Proposed solution #2:</strong> Ok but what if the ARM7TDMI has some way of processing chunk #1 of cycle
<code>n</code> on cycle <code>n - 1</code>, but only if cycle <code>n - 1</code> is the last cycle of the algorithm?</p><p><strong>Rebuttal:</strong> Sure, maybe this is possible, but it feels like any solution that would allow the algorithm to do this would also
be capable of allowing the CPU to do 5 chunks per cycle.</p><p><strong>Proposed solution #3:</strong> Fine, what if the CPU actually leverages the power of Cthulu and evil warlock
magic to pull this off?</p><p><strong>Rebuttal:</strong> Yeah, that&rsquo;s assigning too much credit to this god forsaken bundle of wires that somehow
obtained the title of &ldquo;CPU&rdquo;.</p><p>I was kind of out of ideas. I was pretty much ready to give up - my current algorithm was nowhere near
explaining the behavior of the CPU carry flag. And so I took a break, only looking at this problem every
once in a while.</p><h1 id=descent-into-madness>Descent into Madness<a href=#descent-into-madness class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Congrats for getting this far, now comes the tricky stuff. I require anyone who wants to continue reading to
put on <a href="https://www.google.com/url?sa=t&source=web&rct=j&opi=89978449&url=https://www.youtube.com/watch?v=ntgaStqpmjQ&ved=2ahUKEwj03pfgvs2IAxWjJTQIHTp_EToQtwJ6BAgIEAI&usg=AOvVaw1qRD2jAXNcY-9YA6Uhb9Ig">this music</a> in the background, as it most accurately models the trek into insanity we are about to endure.</p><p>So fast forward about a year, I&rsquo;m out for a walk and I decide to give this problem a thought again. And so I considered something that, at the outset, sounds really, really stupid.</p><p>&ldquo;What if we left shifted the <span style=color:#3a7dc9><strong>multiplier</strong></span> by 1 at the beginning of the algorithm?&rdquo;</p><p>I mean, it&rsquo;s kind of dumb, right? The entire issue is that the <span style=color:#3a7dc9><strong>multiplier</strong></span> is <em>too big</em>. Left shifting it would only exacerbate this issue. Congrats, we went from being able to process 7 bits on the first cycle to 6.</p><p>But pay attention to the <strong>first addend</strong> that would be produced. The corresponding <strong>chunk</strong> would either be <code>000</code> or <code>100</code>. Two options, both of which are really easy to compute. This is a <strong>chunk</strong> that would only exist on the first cycle of the algorithm. Coincidentally, if you refer to the diagram[have actual link or figure #] up above, you&rsquo;ll notice that, in the first cycle of the algorithm, we have an extra input in the CSA array that we initialized to zero. What if, instead, we initialize it to the addend produced by this mythical <strong>chunk</strong>?</p><p>It&rsquo;d solve the issue. It&rsquo;d get us the extra bit we needed, and make us match the ARM7TDMI&rsquo;s cycle counts completely.</p><p>But that&rsquo;s not all. Remember the carry flag from earlier? With this simple change, we go from matching hardware about 50% of the time (no better than randomly guessing) to matching hardware <em><strong>85%</strong></em> of the time. This sudden increase was something no other theory was able to do, and made me really confident that I was on to something. However, this percentage only happens if we set the carry flag to bit <code>30</code> of the partial carry result, which seems super arbitrary. It turns out that bit of the partial carry result had a special meaning I did not realize at the time, and I would only find out that meaning much, much later.</p><h1 id=mathematical-black-magic>Mathematical Black Magic<a href=#mathematical-black-magic class=hanchor arialabel=Anchor>&#8983;</a></h1><p>It feels like we are finally making some sort of progress, however my algorithm still failed to calculate the carry flag properly around 15% of the time, and failed way more than that on long / signed multiplies. It was around this time that I found two patents [link later] that almost <em>entirely</em> explained the algorithm. No idea how these hadn&rsquo;t been found up until this point, but they were quite illuminating.</p><p>After reading the patents, it turns out my implementation of the CSA array is slightly flawed (see <a href=/post/multiply/#perform_csa_array><code>perform_csa_array</code></a> above). In particular, that function uses CSAs with a width of <em>64</em> bits. That&rsquo;s way too large and wastes space on the chip - the actual hardware gets away with only using <em>31</em>.</p><p>Another difference is that my algorithm has no way yet of supporting long accumulate values. Sure, I can initialize the partial output with the accumulate value, but the partial output is only 32 bits wide.</p><p>Turns out, the patents describe a way to deal with both of these issues at once, using some mathematical trickery. This is the hardest part of the algorithm, so hang in there. (cite)</p><p>Roughly, on each CSA, we want to add three numbers together to produce two numbers. Let&rsquo;s give these five numbers some names. Define <code>S</code> to be a 33-bit value (even though the actual S is 32-bits, adding an extra bit allows us to handle both signed and unsigned multiplication) representing the previous CSA&rsquo;s sum, <code>C</code> to be a 33-bit value representing the previous CSA&rsquo;s carry, and <code>S'</code> and <code>C'</code> to be 33-bit values representing the resulting CSA sum / carry. Finally, define <code>X</code> to be a 34-bit value containing the current booths addend. Then we have:</p>$$
S', C' = S + C + X
$$<p>This, mathematically speaking, can be represented as a 65-bit addition. The reason why is that <code>X</code> can be left-shifted by as little as 0, and as much as 32. If we define <code>i</code> to be a number from <code>[0 - 3]</code> representing the CSA&rsquo;s position in the CSA array, we can divide the 65 bit CSA addition region into five chunks:</p><ul><li>Lower: A region of size <code>2i</code> that represents <code>final_csa_output</code>. This region is unaffected by future CSAs.</li><li>TransL: The two bits of CSA <code>#i</code> that will become Lower bits in CSA <code>#(i + 1)</code>.</li><li>Active: The 31-bit region where, including TransL, the actual CSA will be performed.</li><li>TransH: The two bits of CSA <code>#i</code> that will become Active bits in CSA <code>#(i + 1)</code></li><li>High: Contains values that have not yet been put into the CSA.
34-bit value containing the current booths addend.</li></ul><p>Define <code>A</code> to be a <code>65-bit</code> accumulate (even though the actual accumulate is 64-bits, adding an extra bit allows us to handle both signed and unsigned accumulates). Define <code>SL</code> and <code>CL</code> to be the analogue of <code>final_csa_output</code> in (see <a href=/post/multiply/#perform_csa_array><code>the code snippet above</code></a> above). Finally, define <code>XC</code> to be the carry flag produced by booth recoding. Then, we can model the CSA as follows:</p><table><thead><tr><th>Region:</th><th>High</th><th>TransH</th><th>Active</th><th>TransL</th><th>Lower</th></tr></thead><tbody><tr><td>Size:</td><td>30 - 2i</td><td>2</td><td>31</td><td>2</td><td>2i</td></tr><tr><td>Addend #1:</td><td>0</td><td>0</td><td>S[32:2]</td><td>S[1:0]</td><td>SL[2i:0]</td></tr><tr><td>Addend #2:</td><td>C[32], &mldr;, C[32]</td><td>C[32] C[32]</td><td>C[32:2]</td><td>C[1:0]</td><td>CL[2i:0]</td></tr><tr><td>Addend #3:</td><td>X[33], &mldr;, X[33]</td><td>X[33] X[33]</td><td>X[32:2]</td><td>X[1:0]</td><td>0</td></tr><tr><td>Result Sum:</td><td>0</td><td>S&rsquo;[32:31]</td><td>S&rsquo;[30:0]</td><td>SL[2i+2:2i]</td><td>SL[2i:0]</td></tr><tr><td>Result Carry:</td><td>C&rsquo;[32], &mldr;, C&rsquo;[32]</td><td>C&rsquo;[32:31]</td><td>C&rsquo;[30:0]</td><td>CL[2i+2], XC (aka CL[2i+1])</td><td>CL[2i:0]</td></tr></tbody></table><p>Seriously, take time to make sure you understand this table. It represents the CSA that we want to be able to perform.</p><p>Here&rsquo;s a simple way to implement long accumulates. 33 bits of the <code>A</code> will be placed in <code>S</code> as initialization. Meanwhile, we can shove the other <code>31</code> bits, two bits per CSA, into the high region of addend #1.</p><table><thead><tr><th>Region:</th><th>High</th><th>TransH</th><th>Active</th><th>TransL</th><th>Lower</th></tr></thead><tbody><tr><td>Size:</td><td>30 - 2i</td><td>2</td><td>31</td><td>2</td><td>2i</td></tr><tr><td>Addend #1:</td><td>0</td><td>A[2i+35 : 2i+34]</td><td>S[32:2]</td><td>S[1:0]</td><td>SL[2i:0]</td></tr><tr><td>Addend #2:</td><td>C[32], &mldr;, C[32]</td><td>C[32] C[32]</td><td>C[32:2]</td><td>C[1:0]</td><td>CL[2i:0]</td></tr><tr><td>Addend #3:</td><td>X[33], &mldr;, X[33]</td><td>X[33] X[33]</td><td>X[32:2]</td><td>X[1:0]</td><td>0</td></tr><tr><td>Result Sum:</td><td>0</td><td>S&rsquo;[32:31]</td><td>S&rsquo;[30:0]</td><td>SL[2i+2:2i]</td><td>SL[2i:0]</td></tr><tr><td>Result Carry:</td><td>C&rsquo;[32], &mldr;, C&rsquo;[32]</td><td>C&rsquo;[32:31]</td><td>C&rsquo;[30:0]</td><td>CL[2i+2], XC (aka CL[2i+1])</td><td>CL[2i:0]</td></tr></tbody></table><p>We can ignore the Lower column, since the result there is always the same as the addends. We can also ignore the TransL and Active columns, as the operation in those two columns can be implemented using a simple 33-bit CSA (and we already have shown how to do so in <a href=/post/multiply/#perform_csa_array><code>perform_csa_array</code></a> above). This leaves:</p><table><thead><tr><th>Region:</th><th>High</th><th>TransH</th></tr></thead><tbody><tr><td>Size:</td><td>30 - 2i</td><td>2</td></tr><tr><td>Addend #1:</td><td>0</td><td>A[2i+35 : 2i+34]</td></tr><tr><td>Addend #2:</td><td>C[32], &mldr;, C[32]</td><td>C[32] C[32]</td></tr><tr><td>Addend #3:</td><td>X[33], &mldr;, X[33]</td><td>X[33] X[33]</td></tr><tr><td>Result Sum:</td><td>0</td><td>S&rsquo;[32:31]</td></tr><tr><td>Result Carry:</td><td>C&rsquo;[32], &mldr;, C&rsquo;[32]</td><td>C&rsquo;[32:31]</td></tr></tbody></table><p>We can replace Addend #2 with one row of all ones, and another row with just <code>!C[N]</code>. Convince yourself why this is mathematically OK.</p><table><thead><tr><th>Region:</th><th>High</th><th>TransH</th></tr></thead><tbody><tr><td>Size:</td><td>30 - 2i</td><td>2</td></tr><tr><td>Addend #1:</td><td>0</td><td>A[2i+35 : 2i+34]</td></tr><tr><td>Addend #2:</td><td>1, &mldr;, 1</td><td>1 1</td></tr><tr><td>Addend #2.5:</td><td>0</td><td>0 !C[32]</td></tr><tr><td>Addend #3:</td><td>X[33], &mldr;, X[33]</td><td>X[33] X[33]</td></tr><tr><td>Result Sum:</td><td>0</td><td>S&rsquo;[32:31]</td></tr><tr><td>Result Carry:</td><td>C&rsquo;[32], &mldr;, C&rsquo;[32]</td><td>C&rsquo;[32:31]</td></tr></tbody></table><p>Do the same to Addend #3:</p><table><thead><tr><th>Region:</th><th>High</th><th>TransH</th></tr></thead><tbody><tr><td>Size:</td><td>30 - 2i</td><td>2</td></tr><tr><td>Addend #1:</td><td>0</td><td>A[2i+35 : 2i+34]</td></tr><tr><td>Addend #2:</td><td>1, &mldr;, 1</td><td>1 1</td></tr><tr><td>Addend #2.5:</td><td>0</td><td>0 !C[32]</td></tr><tr><td>Addend #3:</td><td>1, &mldr;, 1</td><td>1 1</td></tr><tr><td>Addend #3.5:</td><td>0</td><td>0 !X[33]</td></tr><tr><td>Result Sum:</td><td>0</td><td>S&rsquo;[32:31]</td></tr><tr><td>Result Carry:</td><td>C&rsquo;[32], &mldr;, C&rsquo;[32]</td><td>C&rsquo;[32:31]</td></tr></tbody></table><p>Now, Addends #2 and #3 can be added together, being replaced by a new <code>Addend #4</code>.</p><table><thead><tr><th>Region:</th><th>High</th><th>TransH</th></tr></thead><tbody><tr><td>Size:</td><td>30 - 2i</td><td>2</td></tr><tr><td>Addend #1:</td><td>0</td><td>A[2i+35 : 2i+34]</td></tr><tr><td>Addend #2.5:</td><td>0</td><td>0 !C[32]</td></tr><tr><td>Addend #3.5:</td><td>0</td><td>0 !X[33]</td></tr><tr><td>Addend #4:</td><td>1, &mldr;, 1</td><td>1 0</td></tr><tr><td>Result Sum:</td><td>0</td><td>S&rsquo;[32:31]</td></tr><tr><td>Result Carry:</td><td>C&rsquo;[32], &mldr;, C&rsquo;[32]</td><td>C&rsquo;[32:31]</td></tr></tbody></table><p>Now we can define <code>S'</code> as:
<code>S'[32:31] = A[2i + 34] + !C[32] + !X[33]</code></p><p>We can now remove <code>S'</code> and the bits used to calculate it. Let&rsquo;s see what&rsquo;s left.</p><table><thead><tr><th>Region:</th><th>High</th><th>TransH</th></tr></thead><tbody><tr><td>Size:</td><td>30 - 2i</td><td>2</td></tr><tr><td>Addend #1:</td><td>0</td><td>A[2i+35] 0</td></tr><tr><td>Addend #4:</td><td>1, &mldr;, 1</td><td>1 0</td></tr><tr><td>Result Carry:</td><td>C&rsquo;[32], &mldr;, C&rsquo;[32]</td><td>C&rsquo;[32:31]</td></tr></tbody></table><p>Meaning <code>C'[32] = !A[2i+35]</code>.</p><p>And with that, we managed to go from using 64 bits of CSA, to only 33. Our final algorithm for the CSAs is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>struct</span> CSAOutput <span style=color:#a6e22e>perform_csa_array</span>(u64 partial_sum, u64 partial_carry, BoothRecodingOutput addends[<span style=color:#ae81ff>4</span>]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> CSAOutput csa_output <span style=color:#f92672>=</span> { partial_sum, partial_carry };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> CSAOutput final_csa_output <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        csa_output.output <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0x1FFFFFFFFULL</span>;
</span></span><span style=display:flex><span>        csa_output.carry  <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0x1FFFFFFFFULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> CSAOutput result <span style=color:#f92672>=</span> <span style=color:#a6e22e>perform_csa</span>(csa_output.output, addends.m[i].recoded_output <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x1FFFFFFFFULL</span>, csa_output.carry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Inject the carry caused by booth recoding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        result.carry <span style=color:#f92672>&lt;&lt;=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        result.carry <span style=color:#f92672>|=</span> addends.m[i].carry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Take the bottom two bits and inject them into the final output.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// The value of the bottom two bits will not be changed by future
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// addends, because those addends must be at least 4 times as big
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// as the current addend. By directly injecting these two bits, the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// hardware saves some space on the chip.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        final_csa_output.output <span style=color:#f92672>|=</span> (result.output <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i);
</span></span><span style=display:flex><span>        final_csa_output.carry  <span style=color:#f92672>|=</span> (result.carry  <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The next CSA will only operate on the upper bits - as explained
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// in the previous comment.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        result.output <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        result.carry  <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Perform the magic described in the tables for the handling of TransH
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// and High. acc_shift_register contains the upper 31 bits of the acc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// in its lower bits.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        u64 magic <span style=color:#f92672>=</span> <span style=color:#a6e22e>bit</span>(acc_shift_register, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>+</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>bit</span>(csa_output.carry, <span style=color:#ae81ff>32</span>) <span style=color:#f92672>+</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>bit</span>(addends.m[i].recoded_output, <span style=color:#ae81ff>33</span>);
</span></span><span style=display:flex><span>        result.output <span style=color:#f92672>|=</span> magic <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>31</span>;
</span></span><span style=display:flex><span>        result.carry <span style=color:#f92672>|=</span> (u64) <span style=color:#f92672>!</span><span style=color:#a6e22e>bit</span>(acc_shift_register, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>32</span>;        
</span></span><span style=display:flex><span>        acc_shift_register <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        csa_output <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    final_csa_output.output <span style=color:#f92672>|=</span> csa_output.output <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>    final_csa_output.carry  <span style=color:#f92672>|=</span> csa_output.carry  <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> final_csa_output;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=the-specifics-of-early-termination>The Specifics of Early Termination<a href=#the-specifics-of-early-termination class=hanchor arialabel=Anchor>&#8983;</a></h1><p>We already touched on early termination briefly, but turns out it gets a bit more complicated. The patents don&rsquo;t exactly explain how early termination works here in much detail, besides some cryptic references to shift types / shift values. More importantly, we can implement early termination quite simply, like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>should_terminate</span>(u64 multiplier, <span style=color:#66d9ef>enum</span> MultiplicationFlavor flavor) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>is_signed</span>(flavor)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> multiplier <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x1FFFFFFFF</span> <span style=color:#f92672>||</span> multiplier <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> multiplier <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that <span style=color:#3a7dc9><strong>multiplier</strong></span> is a signed 33-bit number. Now here&rsquo;s the main issue with early termination. After every cycle of booth&rsquo;s algorithm, a total of 41 bits of result are produced. To convince yourself of this, look at the final two lines of <code>perform_csa_array</code>. The bottom eight bits contain the result of each CSA, and the upper 33 bits above those 8 contain <code>csa_output</code>. After every cycle of booth&rsquo;s algorithm, the bottom eight bits are fed into a result register, since the <em>next</em> cycle of booth&rsquo;s algorithm cannot change the value of those bottom eight bits. The upper 33 bits become the next input into the next cycle of booth&rsquo;s algorithm. Something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// I&#39;m using this over a __uint128_t since the latter isn&#39;t available
</span></span></span><span style=display:flex><span><span style=color:#75715e>// on a GBA, and I need this code to compile on a GBA so I can fuzz the 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// outputs.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> u128 {
</span></span><span style=display:flex><span>    u64 lo;
</span></span><span style=display:flex><span>    u64 hi;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Latches that contain the final results of the algorithm.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Really, these only need to be 66 bits, but 128 is good enough.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Why 66? Because:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// - We obtain 1 bit from initialization (EXPLAIN)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// - We obtain 8 * 4 bits from booths algorithm
</span></span></span><span style=display:flex><span><span style=color:#75715e>// - We obtain 33 more bits also from booths algorithm.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>__uint128_t partial_sum;
</span></span><span style=display:flex><span>__uint128_t partial_carry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>    csa_output <span style=color:#f92672>=</span> <span style=color:#a6e22e>perform_one_cycle_of_booths_mutliplication</span>(
</span></span><span style=display:flex><span>        csa_output, multiplicand, multiplier);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    partial_sum.lo   <span style=color:#f92672>|=</span> csa_output.output <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF</span>;
</span></span><span style=display:flex><span>    partial_carry.lo <span style=color:#f92672>|=</span> csa_output.carry  <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    csa_output.output <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>    csa_output.carry  <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    partial_carry <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    multiplier <span style=color:#f92672>=</span> <span style=color:#a6e22e>asr</span>(multiplier, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>33</span>);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>should_terminate</span>(multiplier, flavor));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>partial_sum.lo   <span style=color:#f92672>|=</span> csa_output.output;
</span></span><span style=display:flex><span>partial_carry.lo <span style=color:#f92672>|=</span> csa_output.carry;
</span></span></code></pre></div><p>Since <code>partial_sum</code> and <code>partial_carry</code> are shift registers that get rotated with each iteration of booths algorithm, we need to rotate them again after the algorithm ends in order to correct them to their proper values. The <code>partial_carry</code>&rsquo;s rotation is done via the ARM7TDMI&rsquo;s barrel shifter (explain what tha barrel shifteris), with the output of the barrel shifter going to the ALU. For long (64-bit) multiplies, two rotations occur, since the ALU can only add 32-bits at a time and so must be used twice.</p><p>Spoiler alert, the value of the carry flag after a multiply instruction comes from the carryout of this barrel shifter.</p><p>So, what rotation values does the ARM7TDMI use? According to the patents, for an unsigned multiply, all (1 or 2) uses of the barrel shifter do:</p><table><thead><tr><th># Iterations</th><th>Type</th><th>Rotation</th></tr></thead><tbody><tr><td>1</td><td>ROR</td><td>22</td></tr><tr><td>2</td><td>ROR</td><td>14</td></tr><tr><td>3</td><td>ROR</td><td>6</td></tr><tr><td>4</td><td>ROR</td><td>30</td></tr></tbody></table><p>Signed multiplies differ from unsigned multiplies in their <strong>second</strong> barrel shift. The second one for signed multiplies looks like this:</p><table><thead><tr><th># Iterations</th><th>Type</th><th>Rotation</th></tr></thead><tbody><tr><td>1</td><td>ASR</td><td>22</td></tr><tr><td>2</td><td>ASR</td><td>14</td></tr><tr><td>3</td><td>ASR</td><td>6</td></tr><tr><td>4</td><td>ROR</td><td>30</td></tr></tbody></table><p>I&rsquo;m not going to lie, I couldn&rsquo;t make sense of these rotation values. At all. Maybe they were wrong, since they patents already had a couple major errors at this point. No idea. Turns out it doesn&rsquo;t <em>really</em> matter for calculating the carry flag of a multiply instruction. Observe the operation of the ARM7TDMI&rsquo;s <code>ROR</code> and <code>ASR</code>.</p><p>Code from fleroviux&rsquo;s NanoBoyAdvance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ROR</span>(u32<span style=color:#f92672>&amp;</span> operand, u8 amount, <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> carry, <span style=color:#66d9ef>bool</span> immediate) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Note that in booth&#39;s algorithm, the immediate argument will be true, and
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// amount will be non-zero
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ROR #0 equals to RRX #1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (amount <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>immediate) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (amount <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    amount <span style=color:#f92672>%=</span> <span style=color:#ae81ff>32</span>;
</span></span><span style=display:flex><span>    operand <span style=color:#f92672>=</span> (operand <span style=color:#f92672>&gt;&gt;</span> amount) <span style=color:#f92672>|</span> (operand <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#ae81ff>32</span> <span style=color:#f92672>-</span> amount));
</span></span><span style=display:flex><span>    carry <span style=color:#f92672>=</span> operand <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>31</span>;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> lsb <span style=color:#f92672>=</span> operand <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    operand <span style=color:#f92672>=</span> (operand <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>|</span> (carry <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>31</span>);
</span></span><span style=display:flex><span>    carry <span style=color:#f92672>=</span> lsb;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ASR</span>(u32<span style=color:#f92672>&amp;</span> operand, u8 amount, <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> carry, <span style=color:#66d9ef>bool</span> immediate) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Note that in booth&#39;s algorithm, the immediate argument will be true, and
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// amount will be non-zero and less than 32.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (amount <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ASR #0 equals to ASR #32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (immediate) {
</span></span><span style=display:flex><span>      amount <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> msb <span style=color:#f92672>=</span> operand <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>31</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (amount <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>32</span>) {
</span></span><span style=display:flex><span>    carry <span style=color:#f92672>=</span> msb;
</span></span><span style=display:flex><span>    operand <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xFFFFFFFF</span> <span style=color:#f92672>*</span> msb;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  carry <span style=color:#f92672>=</span> (operand <span style=color:#f92672>&gt;&gt;</span> (amount <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  operand <span style=color:#f92672>=</span> (operand <span style=color:#f92672>&gt;&gt;</span> amount) <span style=color:#f92672>|</span> ((<span style=color:#ae81ff>0xFFFFFFFF</span> <span style=color:#f92672>*</span> msb) <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#ae81ff>32</span> <span style=color:#f92672>-</span> amount));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that in both ROR and ASR the carry will always be set to the last bit of the <code>operand</code> to be shifted out. e.g., if I rotate a value by <code>n</code>, then the carry will always be bit <code>n - 1</code> of the <code>operand</code>, since that was the last bit to be rotated out. Same goes for ASR.</p><p>So, <em>it doesn&rsquo;t matter</em> if I don&rsquo;t use the same rotation values as the patents. Since, no matter the rotation value, as long as the output from <em>my</em> barrel shifter is the same as the output from the <em>ARM7TDMI&rsquo;s</em> barrel shifter, and the input to <em>my</em> barrel shift is the same as the input to the <em>ARM7TDMI&rsquo;s</em> barrel shifter, then the last bit to be shifted out must be the same, and therefore the carry flag must <em>also</em> have been the same.</p><p>So, here&rsquo;s my implementation. I tried to somewhat mimic the table from above, but I didn&rsquo;t do a very good job. But it works, so fuck it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>// I&#39;m using this over a __uint128_t since the latter isn&#39;t available
</span></span></span><span style=display:flex><span><span style=color:#75715e>// on a GBA, and I need this code to compile on a GBA so I can fuzz the 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// outputs.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> u128 {
</span></span><span style=display:flex><span>    u64 lo;
</span></span><span style=display:flex><span>    u64 hi;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// we have ror&#39;d partial_sum and partial_carry by 8 * num_iterations + 1
</span></span></span><span style=display:flex><span><span style=color:#75715e>// we now need to ror backwards, i tried my best to mimic the table, but
</span></span></span><span style=display:flex><span><span style=color:#75715e>// i&#39;m off by one for whatever reason.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> correction_ror;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (num_iterations <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) correction_ror <span style=color:#f92672>=</span> <span style=color:#ae81ff>23</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (num_iterations <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>) correction_ror <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (num_iterations <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>) correction_ror <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (num_iterations <span style=color:#f92672>==</span> <span style=color:#ae81ff>4</span>) correction_ror <span style=color:#f92672>=</span> <span style=color:#ae81ff>31</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>partial_sum   <span style=color:#f92672>=</span> <span style=color:#a6e22e>u128_ror</span>(partial_sum, correction_ror);
</span></span><span style=display:flex><span>partial_carry <span style=color:#f92672>=</span> <span style=color:#a6e22e>u128_ror</span>(partial_carry, correction_ror);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> alu_carry_in <span style=color:#f92672>=</span> <span style=color:#a6e22e>bit</span>(multiplier, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>is_long</span>(flavor)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (num_iterations <span style=color:#f92672>==</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> AdderOutput adder_output_lo <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>adder</span>(partial_sum.hi, partial_carry.hi, alu_carry_in);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> AdderOutput adder_output_hi <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>adder</span>(partial_sum.hi <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>, partial_carry.hi <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>, 
</span></span><span style=display:flex><span>                  adder_output_lo.carry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> MultiplicationOutput) {
</span></span><span style=display:flex><span>            ((u64) adder_output_hi.output <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>32</span>) <span style=color:#f92672>|</span> adder_output_lo.output,
</span></span><span style=display:flex><span>            (partial_carry.hi <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>63</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> AdderOutput adder_output_lo <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>adder</span>(partial_sum.hi <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>, partial_carry.hi <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>, alu_carry_in);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> shift_amount <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>*</span> num_iterations;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// why this is needed is unknown, but the multiplication doesn&#39;t work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// without it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        shift_amount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        partial_carry.lo <span style=color:#f92672>=</span> <span style=color:#a6e22e>sign_extend</span>(partial_carry.lo, shift_amount, <span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>        partial_sum.lo <span style=color:#f92672>|=</span> acc_shift_register <span style=color:#f92672>&lt;&lt;</span> (shift_amount);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> AdderOutput adder_output_hi <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>adder</span>(partial_sum.lo, partial_carry.lo, adder_output_lo.carry);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> MultiplicationOutput) { 
</span></span><span style=display:flex><span>            ((u64) adder_output_hi.output <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>32</span>) <span style=color:#f92672>|</span> adder_output_lo.output,
</span></span><span style=display:flex><span>            (partial_carry.hi <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>63</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (num_iterations <span style=color:#f92672>==</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> AdderOutput adder_output <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>adder</span>(partial_sum.hi, partial_carry.hi, alu_carry_in);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> MultiplicationOutput) { 
</span></span><span style=display:flex><span>            adder_output.output,
</span></span><span style=display:flex><span>            (partial_carry.hi <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>31</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> AdderOutput adder_output <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>adder</span>(partial_sum.hi <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>, partial_carry.hi <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>, alu_carry_in);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>struct</span> MultiplicationOutput) { 
</span></span><span style=display:flex><span>            adder_output.output,
</span></span><span style=display:flex><span>            (partial_carry.hi <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>63</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Anyway, that&rsquo;s basically it. If you&rsquo;re interested in the full code, take a look <a href=https://github.com/zaydlang/multiplication-algorithm/tree/master>here</a>.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://beanmachine.alt.icu/post/d_on_gba/><span class=button__text>Porting D to GBA</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2019-2024. CC BY-NC-SA 4.0</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://beanmachine.alt.icu/assets/main.js></script><script src=https://beanmachine.alt.icu/assets/prism.js></script></div></body></html>